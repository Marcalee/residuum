<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TileWord – Drag & Drop</title>
  <style>
    :root{
      --bg:#0f1216; --panel:#151a20; --line:#222a35; --ink:#e6edf3; --muted:#9aa7b5;
      --tile:#161d26; --tileSel:#1a3347; --stroke:#2a3442;
      --accent:rgba(139,211,255,0.85);
      --good:#7dffb2; --bad:#ff8b8b;
    }
    html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink);}
    .wrap{max-width:1120px; margin:0 auto; padding:16px;}
    .row{display:flex; gap:14px; align-items:flex-start; flex-wrap:wrap;}
    canvas{background:#0b0e12; border:1px solid var(--line); border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,0.35); touch-action:none;}
    .panel{background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:12px; box-shadow:0 8px 24px rgba(0,0,0,0.25); min-width:350px;}
    .stats{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:12px;}
    .stat{background:#11161d; border:1px solid var(--line); border-radius:12px; padding:10px;}
    .stat .k{font-size:12px; color:var(--muted);}
    .stat .v{font-size:18px; font-weight:850; margin-top:2px;}
    .controls{display:flex; flex-wrap:wrap; gap:8px; margin-bottom:10px;}
    button{background:#11161d; border:1px solid #2a3442; color:var(--ink); padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:760;}
    button:hover{border-color:#3b4a5f;}
    button.primary{background:#13202b; border-color:#27465f; color:#d9f1ff;}
    button:disabled{opacity:0.45; cursor:not-allowed;}

    .trayWrap{margin-top:8px;}
    .trayHeader{display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap; margin:6px 0;}
    .trayHeader .hint{font-size:12px; color:var(--muted);}
    .tray{display:grid; grid-template-columns:repeat(7, 1fr); gap:8px; padding:10px; background:#10151c; border:1px solid var(--line); border-radius:12px; user-select:none;}
    .slot{height:44px; border-radius:12px; border:1px dashed #2a3442; display:flex; align-items:center; justify-content:center; color:#90a0b3; position:relative; user-select:none;}
    .slot.filled{border-style:solid; border-color:#2a3442; background:#1f2630; color:var(--ink); font-weight:900;}
    .slot .tag{position:absolute; left:8px; top:6px; font-size:10px; color:#9aa7b5; opacity:0.85; font-weight:800;}
    .slot .mini{position:absolute; right:8px; bottom:6px; font-size:10px; color:#a9b8c8; opacity:0.75;}
    .slot.filled:hover{outline:2px solid rgba(139,211,255,0.35);}

    .msg{margin-top:10px; padding:10px 12px; border-radius:12px; border:1px solid #2a3442; background:#0f151c; color:#cfe6f6;}
    .msg.good{border-color:#2d6248; background:#0f1b14; color:#d7ffe8;}
    .msg.bad{border-color:#6a2d2d; background:#1b0f10; color:#ffd7d7;}

    .rules{margin-top:10px; font-size:12px; color:#a6b3c0; line-height:1.35;}
    .rules code{background:#0f151c; border:1px solid #273141; border-radius:8px; padding:1px 6px;}

    .dictRow{display:flex; align-items:center; gap:10px; flex-wrap:wrap; margin:8px 0 2px;}
    .dictRow label{font-size:12px; color:var(--muted);}
    .dictRow input[type="file"]{font-size:12px; color:var(--muted);}
    .pill{font-size:12px; color:var(--muted); border:1px solid var(--line); background:#10151c; padding:6px 10px; border-radius:999px;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <canvas id="c" width="560" height="560"></canvas>
    <div class="panel">
      <div class="stats">
        <div class="stat"><div class="k">Round</div><div class="v" id="round">1</div></div>
        <div class="stat"><div class="k">Score</div><div class="v" id="score">0</div></div>
        <div class="stat"><div class="k">Tray</div><div class="v" id="trayCt">0</div></div>
        <div class="stat"><div class="k">Selection</div><div class="v" id="selCt">0</div></div>
      </div>

      <div class="controls">
        <button class="primary" id="btnSubmit" disabled>Submit</button>
        <button id="btnClear" disabled>Clear</button>
        <button id="btnRestart">Restart</button>
      </div>

      <div class="dictRow">
  <span class="hint">Dictionary:</span>
  <span class="pill" id="dictInfo">Loading…</span>
</div>

<div class="trayWrap">
        <div class="trayHeader">
          <div class="hint">Drag tiles <b>to</b> tray (save) and <b>back</b> to board (swap/place). Unlimited swaps.</div>
          <div class="hint">Cap: <b>5</b> singles + <b>2</b> digraphs</div>
        </div>
        <div class="tray" id="tray"></div>
      </div>

      <div class="msg" id="msg">Loading dictionaries…</div>

      <div class="rules">
        <b>Rules</b><br/>
        • Build a <b>connected</b> path (8-way). No repeats. (2+ tiles)<br/>
        • Dictionary word: <code>+10 × tiles</code> plus bonus <code>+5 × (letters)²</code> (digraphs count as 2 letters).<br/>
        • Non-word clears space but costs <code>−10 × tiles</code>.<br/>
      </div>
    </div>
  </div>
</div>

<script>
(async () => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    round: document.getElementById('round'),
    score: document.getElementById('score'),
    trayCt: document.getElementById('trayCt'),
    selCt: document.getElementById('selCt'),
    tray: document.getElementById('tray'),
    msg: document.getElementById('msg'),
    btnSubmit: document.getElementById('btnSubmit'),
    btnClear: document.getElementById('btnClear'),
    btnRestart: document.getElementById('btnRestart'), 
dictInfo: document.getElementById('dictInfo'),
  };

  // ======= CONFIG =======
  const N = 7;
  const PAD = 18;
  const CELL = Math.floor((canvas.width - PAD*2) / N);
  const MIN_WORD_LEN_TILES = 2;

  const TARGET_FILL = 0.90;
  const SPAWN_PER_SUBMIT = 2;

  const TRAY_MAX_SINGLE = 5;
  const TRAY_MAX_DIGRAPH = 2;

  const DIGRAPH_PROB = 0.22;

  // ======= DICTIONARY =======
  const BUILTIN_WORDS = [
    "A","I","AN","IN","ON","AT","TO","OF","AS","IS","IT","WE","ME","HE","BE","DO","GO","NO","SO","OR",
    "AND","THE","YOU","ONE","EAT","ATE","TEA","TEN","TON","NOT","NOW","OWN","WON","SON","SUN","RUN","FUN",
    "HEN","HER","HIS","HIM","SHE","SEE","SEA","SET","GET","LET","NET","BET","YET","ARE","WAS","WERE","HAS","HAD","HAVE",
    "FOR","FROM","WITH","THIS","THAT","THEY","THEM","THEN","WHEN","WHAT","WHERE","WHO","WHY","HOW",
    "WORD","WORDS","TILE","TILES","GAME","PLAY","SCORE","POINT","ROUND","SAVE","PLACE","BUILD","FORM","MADE","MAKE",
    "CLEAR","SPACE","BOARD","PATH","TRACE",
    "MORE","LESS","GOOD","BEST","BETTER","BAD",
    "TIME","NAME","SAME","SOME","COME","HOME","BATS","BAT","BATH","BATHS","OTHER","THERE","THEIR","ABOUT"
  ];

// External dictionaries (placed next to this HTML file)
let DICT_FULL = new Set();   // acceptance
let DICT_COMMON = new Set(); // for later seeding/tone
let DICT = new Set(BUILTIN_WORDS.map(w => w.toUpperCase())); // fallback alias used by the engine

function refreshDictInfo(){
  const full = DICT_FULL.size;
  const common = DICT_COMMON.size;
  if(full && common){
    ui.dictInfo.textContent = `full: ${full.toLocaleString()} / common: ${common.toLocaleString()}`;
  }else{
    ui.dictInfo.textContent = `(fallback: ${DICT.size.toLocaleString()} words)`;
  }
}

async function loadDictionaries(){
  // Uses fetch(); must run from a local server (Live Server is perfect)
  const [fullText, commonText] = await Promise.all([
    fetch("dict_full.txt", {cache:"no-store"}).then(r => { if(!r.ok) throw new Error("dict_full.txt not found"); return r.text(); }),
    fetch("dict_common.txt", {cache:"no-store"}).then(r => { if(!r.ok) throw new Error("dict_common.txt not found"); return r.text(); }),
  ]);

  DICT_FULL = new Set(fullText.split(/\r?\n/).map(s=>s.trim().toUpperCase()).filter(Boolean));
DICT_COMMON = new Set(commonText.split(/\r?\n/).map(s=>s.trim().toUpperCase()).filter(Boolean));


  // Engine validates against DICT
  DICT = DICT_FULL;

  refreshDictInfo();
}


  function setMessage(text, kind="neutral"){
    ui.msg.className = "msg" + (kind==="good" ? " good" : kind==="bad" ? " bad" : "");
    ui.msg.textContent = text;
  }

    // ======= "DECK" MATH =======
  const VOWELS = "AEIOU";
  const VOWEL_BAG = "EEEEEEAAAAOOOIIIIIUU";
  const CONS_BAG  = "TTTTNNNNRRRRSSSSHHHDDDLLLCCMMWWFFGGYYPPBBVVKKJXQZ";

  const DIGRAPH_BAG = [
    "TH","HE","IN","ER","AN","RE","ON","AT","EN","ND","TI","ES","OR","TE","OF","ED","IS","IT","AL","AR",
    "ST","TO","NT","NG","SE","HA","AS","OU","EA","OO","AI","IE","CH","SH","WH","CK"
  ];

  const VOWEL_WINDOW = 30;
  let spawnHistory = [];
  function vowelRatio(){
    if(!spawnHistory.length) return 0.38;
    let v=0; for(const x of spawnHistory) if(x) v++;
    return v / spawnHistory.length;
  }
  function recordSingle(ch){
    spawnHistory.push(VOWELS.includes(ch));
    if(spawnHistory.length > VOWEL_WINDOW) spawnHistory.shift();
  }
  function randFromBag(bag){ return bag[Math.floor(Math.random()*bag.length)]; }
  function randSingle(){
    const r = vowelRatio();
    let pV = 0.38;
    if(r < 0.32) pV = 0.62;
    else if(r > 0.45) pV = 0.26;
    const ch = (Math.random() < pV) ? randFromBag(VOWEL_BAG) : randFromBag(CONS_BAG);
    recordSingle(ch);
    return ch;
  }
  function randDigraph(){ return DIGRAPH_BAG[Math.floor(Math.random()*DIGRAPH_BAG.length)]; }

  function makeTile(token){ return { token, isDigraph: token.length===2 }; }
  function randTile(){
    if(Math.random() < DIGRAPH_PROB) return makeTile(randDigraph());
    return makeTile(randSingle());
  }

  // ======= STATE =======
  let board, tray, selectedPath, score, round;

  // Drag state
  let drag = null;
  const DRAG_THRESHOLD = 6;

  // ======= GEOMETRY =======
  function inBounds(r,c){ return r>=0 && r<N && c>=0 && c<N; }
  function isAdjacent(a,b){
    const dr = Math.abs(a.r - b.r);
    const dc = Math.abs(a.c - b.c);
    return (dr<=1 && dc<=1 && (dr+dc)>0);
  }
  function inPath(r,c){ return selectedPath.some(p => p.r===r && p.c===c); }

  function mouseToCanvas(ev){
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    return {x,y};
  }
  function cellFromCanvasXY(x,y){
    const c = Math.floor((x - PAD)/CELL);
    const r = Math.floor((y - PAD)/CELL);
    if(!inBounds(r,c)) return null;
    return {r,c};
  }

  function rr(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }

  // ======= TRAY CAPS =======
  function trayCounts(){
    let singles=0, digs=0;
    for(const t of tray){
      if(!t) continue;
      if(t.isDigraph) digs++; else singles++;
    }
    return {singles,digs};
  }
  function canAddToTray(tile){
    const {singles,digs} = trayCounts();
    if(tile.isDigraph) return digs < TRAY_MAX_DIGRAPH;
    return singles < TRAY_MAX_SINGLE;
  }
  function firstEmptyTraySlot(isDigraph){
    const start = isDigraph ? 5 : 0;
    const end = isDigraph ? 7 : 5;
    for(let i=start;i<end;i++) if(!tray[i]) return i;
    return -1;
  }
  function addToTray(tile){
    const idx = firstEmptyTraySlot(tile.isDigraph);
    if(idx<0) return false;
    tray[idx] = tile;
    return true;
  }

  // ======= BOARD HELPERS =======
  function filledCount(){
    let n=0;
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(board[r][c]) n++;
    return n;
  }
  function emptyCells(){
    const out=[];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(!board[r][c]) out.push({r,c});
    return out;
  }
  function scoreEmpty(r,c){
    let n=0;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      if(dr===0 && dc===0) continue;
      const rr=r+dr, cc=c+dc;
      if(inBounds(rr,cc) && board[rr][cc]) n++;
    }
    return n;
  }
  function weightedPick(cells){
    const weights = cells.map(p => 1 + Math.pow(scoreEmpty(p.r,p.c), 2));
    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    for(let i=0;i<cells.length;i++){
      r -= weights[i];
      if(r<=0) return cells[i];
    }
    return cells[cells.length-1];
  }
  function emptyNeighbors(r,c){
    const out=[];
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      if(dr===0 && dc===0) continue;
      const rr=r+dr, cc=c+dc;
      if(inBounds(rr,cc) && !board[rr][cc]) out.push({r:rr,c:cc});
    }
    return out;
  }

  function fillToTarget(){
    const total = N*N;
    const target = Math.floor(total * TARGET_FILL);
    let need = Math.max(0, target - filledCount());
    if(need<=0) return;

    const emptiesAll = emptyCells();
    if(!emptiesAll.length) return;

    const adjacentEmpties = emptiesAll.filter(p => scoreEmpty(p.r,p.c) > 0);
    let seedPool = adjacentEmpties.length ? adjacentEmpties : emptiesAll;
    let seed = weightedPick(seedPool);

    while(need>0 && seed){
      board[seed.r][seed.c] = randTile();
      need--;

      if(need<=0) break;
      const neigh = emptyNeighbors(seed.r, seed.c);
      if(neigh.length) seed = weightedPick(neigh);
      else{
        const empties = emptyCells();
        if(!empties.length) break;
        const adj2 = empties.filter(p => scoreEmpty(p.r,p.c) > 0);
        seed = weightedPick(adj2.length ? adj2 : empties);
      }
    }
  }

  function afterSubmitDeal(){
    round += 1;
    fillToTarget();
    let spawned = 0;
    const empties = emptyCells();
    while(spawned < SPAWN_PER_SUBMIT && empties.length){
      const p = empties.splice(Math.floor(Math.random()*empties.length),1)[0];
      board[p.r][p.c] = randTile();
      spawned++;
    }
    fillToTarget();
  }

  function updateUI(){
    ui.round.textContent = String(round);
    ui.score.textContent = String(score);
    const {singles,digs} = trayCounts();
    ui.trayCt.textContent = `${singles+digs}/${TRAY_MAX_SINGLE+TRAY_MAX_DIGRAPH}`;
    ui.selCt.textContent = String(selectedPath.length);

    ui.btnSubmit.disabled = selectedPath.length < MIN_WORD_LEN_TILES;
    ui.btnClear.disabled = selectedPath.length === 0;

    renderTray();
  }

  function renderTray(){
    ui.tray.innerHTML = "";
    const labels = ["S1","S2","S3","S4","S5","DG1","DG2"];
    for(let i=0;i<7;i++){
      const slot = document.createElement("div");
      slot.className = "slot" + (tray[i] ? " filled" : "");
      slot.dataset.idx = String(i);

      const tag = document.createElement("div");
      tag.className = "tag";
      tag.textContent = labels[i];
      slot.appendChild(tag);

      if(tray[i]){
        slot.textContent = tray[i].token;
        slot.appendChild(tag);

        const mini = document.createElement("div");
        mini.className = "mini";
        mini.textContent = tray[i].isDigraph ? "DG" : "1";
        slot.appendChild(mini);

        slot.addEventListener("pointerdown", (ev) => {
          ev.preventDefault();
          const cx = ev.clientX, cy = ev.clientY;
          drag = { source:"tray", idx:i, tile: tray[i], x:cx, y:cy, startX:cx, startY:cy, moved:false };
          slot.setPointerCapture(ev.pointerId);
        });
      }else{
        slot.textContent = "";
      }

      ui.tray.appendChild(slot);
    }
  }

  function reset(){
    board = Array.from({length:N}, () => Array.from({length:N}, () => null));
    tray = Array.from({length:7}, () => null);
    selectedPath = [];
    score = 0;
    round = 1;
    spawnHistory = [];

    fillToTarget();
    setMessage("Load a dictionary file (optional), then play. Drag board ↔ tray; click tiles to select a word path.", "neutral");
    updateUI();
  }

  // ======= INPUT =======
  canvas.addEventListener("pointerdown", (ev) => {
    const {x,y} = mouseToCanvas(ev);
    const cell = cellFromCanvasXY(x,y);
    if(!cell) return;
    const t = board[cell.r][cell.c];
    if(!t) return;
    drag = { source:"board", r:cell.r, c:cell.c, tile:t, x:ev.clientX, y:ev.clientY, startX:ev.clientX, startY:ev.clientY, moved:false };
    canvas.setPointerCapture(ev.pointerId);
  });

  canvas.addEventListener("pointermove", (ev) => {
    if(!drag) return;
    const dx = ev.clientX - drag.startX;
    const dy = ev.clientY - drag.startY;
    if(!drag.moved && Math.hypot(dx,dy) > DRAG_THRESHOLD) drag.moved = true;
    drag.x = ev.clientX; drag.y = ev.clientY;
  });

  // Keep drag coordinates updating even when the pointer is over the panel/tray (tray drag needs this).
  window.addEventListener("pointermove", (ev) => {
    if(!drag) return;
    const dx = ev.clientX - drag.startX;
    const dy = ev.clientY - drag.startY;
    if(!drag.moved && Math.hypot(dx,dy) > DRAG_THRESHOLD) drag.moved = true;
    drag.x = ev.clientX;
    drag.y = ev.clientY;
  }, {capture:true});

  function overTray(){
    const r = ui.tray.getBoundingClientRect();
    return drag && drag.x >= r.left && drag.x <= r.right && drag.y >= r.top && drag.y <= r.bottom;
  }

  function handleDrop(){
    if(!drag) return;

    // Click-to-select
    if(!drag.moved && drag.source === "board"){
      const p = {r:drag.r, c:drag.c};
      if(inPath(p.r,p.c)){ setMessage("No repeats in a word.", "bad"); drag=null; updateUI(); return; }
      if(selectedPath.length){
        const last = selectedPath[selectedPath.length-1];
        if(!isAdjacent(last, p)){ setMessage("Path must stay connected (8-way).", "bad"); drag=null; updateUI(); return; }
      }
      selectedPath.push(p);
      drag=null; updateUI(); return;
    }
    if(!drag.moved && drag.source === "tray"){ drag=null; return; }

    // Board -> tray
    if(drag.source === "board" && overTray()){
      const tile = board[drag.r][drag.c];
      if(!tile){ drag=null; return; }
      if(!canAddToTray(tile)){ setMessage(tile.isDigraph ? "Tray digraph slots are full (2 max)." : "Tray single slots are full (5 max).", "bad"); drag=null; return; }
      if(addToTray(tile)){
        board[drag.r][drag.c] = null;
        selectedPath = selectedPath.filter(p => !(p.r===drag.r && p.c===drag.c));
        setMessage(`Saved ${tile.token} to tray.`, "good");
        updateUI();
      }
      drag=null; return;
    }

    // Tray -> board
    if(drag.source === "tray"){
      const rect = canvas.getBoundingClientRect();
      const overCanvas = drag.x >= rect.left && drag.x <= rect.right && drag.y >= rect.top && drag.y <= rect.bottom;
      if(overCanvas){
        const {x,y} = mouseToCanvas({clientX:drag.x, clientY:drag.y});
        const cell = cellFromCanvasXY(x,y);
        if(cell){
          const held = tray[drag.idx];
          if(!held){ drag=null; return; }
          const target = board[cell.r][cell.c];
          board[cell.r][cell.c] = held;
          tray[drag.idx] = target ? target : null;
          if(target){
            selectedPath = selectedPath.filter(p => !(p.r===cell.r && p.c===cell.c));
            setMessage(`Swapped ${held.token} ↔ ${target.token}.`, "neutral");
          }else{
            setMessage(`Placed ${held.token} onto board.`, "neutral");
          }
          updateUI();
        }
      }
      drag=null; return;
    }

    drag=null;
  }

  canvas.addEventListener("pointerup", () => handleDrop());
  canvas.addEventListener("pointercancel", () => { drag=null; });
  window.addEventListener("pointerup", () => { if(drag) handleDrop(); }, {capture:true});

  // ======= BUTTONS =======
  ui.btnClear.onclick = () => { selectedPath = []; updateUI(); };
  ui.btnSubmit.onclick = () => {
    if(selectedPath.length < MIN_WORD_LEN_TILES) return;

    const tokens = selectedPath.map(p => board[p.r][p.c].token);
    const word = tokens.join("").toUpperCase();
    const tiles = selectedPath.length;
    const letters = tokens.reduce((s,t)=>s+t.length, 0);

    const isWord = DICT.has(word);
    const delta = isWord ? (tiles*10 + 5*letters*letters) : -(tiles*10);
    score += delta;

    for(const p of selectedPath) board[p.r][p.c] = null;
    selectedPath = [];

    setMessage(isWord ? `"${word}" accepted (+${delta})` : `"${word}" rejected (${delta})`, isWord ? "good" : "bad");
    afterSubmitDeal();
    updateUI();
  };
  ui.btnRestart.onclick = () => reset();

  // ======= RENDER =======
  function drawTileAt(token, isDigraph, x, y, selected=false, alpha=1){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = selected ? getComputedStyle(document.documentElement).getPropertyValue('--tileSel') : getComputedStyle(document.documentElement).getPropertyValue('--tile');
    rr(x+4, y+4, CELL-8, CELL-8, 12);
    ctx.fill();

    if(isDigraph){
      ctx.save();
      ctx.globalAlpha = 0.55*alpha;
      ctx.fillStyle = "#223242";
      ctx.beginPath();
      ctx.moveTo(x+CELL-18, y+8);
      ctx.lineTo(x+CELL-8,  y+8);
      ctx.lineTo(x+CELL-8,  y+18);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--stroke');
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "#e6edf3";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = isDigraph ? "900 18px system-ui, -apple-system, Segoe UI, Roboto, Arial" : "900 22px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(token, x + CELL/2, y + CELL/2 + 1);
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // grid
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.strokeStyle = "#1f2630";
    for(let i=0;i<=N;i++){
      const x = PAD + i*CELL;
      const y = PAD + i*CELL;
      ctx.beginPath(); ctx.moveTo(x, PAD); ctx.lineTo(x, PAD + N*CELL); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(PAD, y); ctx.lineTo(PAD + N*CELL, y); ctx.stroke();
    }
    ctx.restore();

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const t = board[r][c];
        if(!t) continue;
        if(drag && drag.source==="board" && drag.moved && drag.r===r && drag.c===c) continue;
        const x = PAD + c*CELL;
        const y = PAD + r*CELL;
        drawTileAt(t.token, t.isDigraph, x, y, inPath(r,c));
      }
    }

    if(selectedPath.length){
      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.lineWidth = 3;
      ctx.beginPath();
      selectedPath.forEach((p,i)=>{
        const cx = PAD + p.c*CELL + CELL/2;
        const cy = PAD + p.r*CELL + CELL/2;
        if(i===0) ctx.moveTo(cx,cy);
        else ctx.lineTo(cx,cy);
      });
      ctx.stroke();
      ctx.restore();
    }

    if(drag && drag.moved){
      const rect = canvas.getBoundingClientRect();
      const cx = (drag.x - rect.left) * (canvas.width / rect.width);
      const cy = (drag.y - rect.top) * (canvas.height / rect.height);
      drawTileAt(drag.tile.token, drag.tile.isDigraph, cx - CELL/2, cy - CELL/2, false, 0.85);
    }

    requestAnimationFrame(draw);
  }

  try{
    ui.msg.textContent = 'Loading dictionaries…';
    await loadDictionaries();
    ui.msg.textContent = 'Ready.';
  }catch(e){
    console.warn(e);
    // fall back silently; still playable with BUILTIN_WORDS
    DICT = new Set(BUILTIN_WORDS.map(w => w.toUpperCase()));
    DICT_FULL = new Set();
    DICT_COMMON = new Set();
    refreshDictInfo();
    ui.msg.textContent = 'Ready (fallback dictionary).';
  }

  reset();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
